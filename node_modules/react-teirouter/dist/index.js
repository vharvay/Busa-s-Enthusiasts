Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

var isProduction = process.env.NODE_ENV === 'production';
function warning(condition, message) {
  if (!isProduction) {
    if (condition) {
      return;
    }

    var text = "Warning: " + message;

    if (typeof console !== 'undefined') {
      console.warn(text);
    }

    try {
      throw Error(text);
    } catch (x) {}
  }
}

var TEIRoutes = /*#__PURE__*/React__default["default"].createContext();

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var cssjson = {exports: {}};

/**
 * CSS-JSON Converter for JavaScript
 * Converts CSS to JSON and back.
 * Version 2.1
 *
 * Released under the MIT license.
 *
 * Copyright (c) 2013 Aram Kocharyan, http://aramk.com/

 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 documentation files (the "Software"), to deal in the Software without restriction, including without limitation
 the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
 to permit persons to whom the Software is furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all copies or substantial portions
 of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
 THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 */

(function (module, exports) {
	/*******************************************************************************
	 *  UMD pattern for exporting module
	 */
	(function (root, factory) {
	    {
	        // Node. Does not work with strict CommonJS, but
	        // only CommonJS-like environments that support module.exports,
	        // like Node.
	        module.exports = factory();
	    }
	}(commonjsGlobal, function () {

	    var CSSJSON = new function () {

	        var base = this;

	        base.init = function () {
	            // String functions
	            String.prototype.trim = function () {
	                return this.replace(/^\s+|\s+$/g, '');
	            };

	            String.prototype.repeat = function (n) {
	                return new Array(1 + n).join(this);
	            };
	        };
	        base.init();
	        var commentX = /\/\*[\s\S]*?\*\//g;
	        var lineAttrX = /([^\:]+):([^\;]*);/;

	        // This is used, a concatenation of all above. We use alternation to
	        // capture.
	        var altX = /(\/\*[\s\S]*?\*\/)|([^\s\;\{\}][^\;\{\}]*(?=\{))|(\})|([^\;\{\}]+\;(?!\s*\*\/))/gmi;

	        // Capture groups
	        var capComment = 1;
	        var capSelector = 2;
	        var capEnd = 3;
	        var capAttr = 4;

	        var isEmpty = function (x) {
	            return typeof x == 'undefined' || x.length == 0 || x == null;
	        };

	        /**
	         * Input is css string and current pos, returns JSON object
	         *
	         * @param cssString
	         *            The CSS string.
	         * @param args
	         *            An optional argument object. ordered: Whether order of
	         *            comments and other nodes should be kept in the output. This
	         *            will return an object where all the keys are numbers and the
	         *            values are objects containing "name" and "value" keys for each
	         *            node. comments: Whether to capture comments. split: Whether to
	         *            split each comma separated list of selectors.
	         */
	        base.toJSON = function (cssString, args) {
	            var node = {
	                children: {},
	                attributes: {}
	            };
	            var match = null;
	            var count = 0;

	            if (typeof args == 'undefined') {
	                var args = {
	                    ordered: false,
	                    comments: false,
	                    stripComments: false,
	                    split: false
	                };
	            }
	            if (args.stripComments) {
	                args.comments = false;
	                cssString = cssString.replace(commentX, '');
	            }

	            while ((match = altX.exec(cssString)) != null) {
	                if (!isEmpty(match[capComment]) && args.comments) {
	                    // Comment
	                    var add = match[capComment].trim();
	                    node[count++] = add;
	                } else if (!isEmpty(match[capSelector])) {
	                    // New node, we recurse
	                    var name = match[capSelector].trim();
	                    // This will return when we encounter a closing brace
	                    var newNode = base.toJSON(cssString, args);
	                    if (args.ordered) {
	                        var obj = {};
	                        obj['name'] = name;
	                        obj['value'] = newNode;
	                        // Since we must use key as index to keep order and not
	                        // name, this will differentiate between a Rule Node and an
	                        // Attribute, since both contain a name and value pair.
	                        obj['type'] = 'rule';
	                        node[count++] = obj;
	                    } else {
	                        if (args.split) {
	                            var bits = name.split(',');
	                        } else {
	                            var bits = [name];
	                        }
	                        for (i in bits) {
	                            var sel = bits[i].trim();
	                            if (sel in node.children) {
	                                for (var att in newNode.attributes) {
	                                    node.children[sel].attributes[att] = newNode.attributes[att];
	                                }
	                            } else {
	                                node.children[sel] = newNode;
	                            }
	                        }
	                    }
	                } else if (!isEmpty(match[capEnd])) {
	                    // Node has finished
	                    return node;
	                } else if (!isEmpty(match[capAttr])) {
	                    var line = match[capAttr].trim();
	                    var attr = lineAttrX.exec(line);
	                    if (attr) {
	                        // Attribute
	                        var name = attr[1].trim();
	                        var value = attr[2].trim();
	                        if (args.ordered) {
	                            var obj = {};
	                            obj['name'] = name;
	                            obj['value'] = value;
	                            obj['type'] = 'attr';
	                            node[count++] = obj;
	                        } else {
	                            if (name in node.attributes) {
	                                var currVal = node.attributes[name];
	                                if (!(currVal instanceof Array)) {
	                                    node.attributes[name] = [currVal];
	                                }
	                                node.attributes[name].push(value);
	                            } else {
	                                node.attributes[name] = value;
	                            }
	                        }
	                    } else {
	                        // Semicolon terminated line
	                        node[count++] = line;
	                    }
	                }
	            }

	            return node;
	        };

	        /**
	         * @param node
	         *            A JSON node.
	         * @param depth
	         *            The depth of the current node; used for indentation and
	         *            optional.
	         * @param breaks
	         *            Whether to add line breaks in the output.
	         */
	        base.toCSS = function (node, depth, breaks) {
	            var cssString = '';
	            if (typeof depth == 'undefined') {
	                depth = 0;
	            }
	            if (typeof breaks == 'undefined') {
	                breaks = false;
	            }
	            if (node.attributes) {
	                for (i in node.attributes) {
	                    var att = node.attributes[i];
	                    if (att instanceof Array) {
	                        for (var j = 0; j < att.length; j++) {
	                            cssString += strAttr(i, att[j], depth);
	                        }
	                    } else {
	                        cssString += strAttr(i, att, depth);
	                    }
	                }
	            }
	            if (node.children) {
	                var first = true;
	                for (i in node.children) {
	                    if (breaks && !first) {
	                        cssString += '\n';
	                    } else {
	                        first = false;
	                    }
	                    cssString += strNode(i, node.children[i], depth);
	                }
	            }
	            return cssString;
	        };

	        // Helpers

	        var strAttr = function (name, value, depth) {
	            return '\t'.repeat(depth) + name + ': ' + value + ';\n';
	        };

	        var strNode = function (name, value, depth) {
	            var cssString = '\t'.repeat(depth) + name + ' {\n';
	            cssString += base.toCSS(value, depth + 1);
	            cssString += '\t'.repeat(depth) + '}\n';
	            return cssString;
	        };

	    };

	    return CSSJSON;
	}));
} (cssjson));

var TEINodes = /*#__PURE__*/function (_React$Component) {
  _inherits(TEINodes, _React$Component);

  var _super = _createSuper(TEINodes);

  function TEINodes() {
    _classCallCheck(this, TEINodes);

    return _super.apply(this, arguments);
  }

  _createClass(TEINodes, [{
    key: "render",
    value: function render() {
      var _this = this;

      var nodes = Array.from(this.props.teiNodes);
      return nodes.map(function (child, i) {
        return /*#__PURE__*/React__default["default"].createElement(TEINode, {
          key: "".concat(child.tagName).concat(i),
          teiNode: child,
          availableRoutes: _this.props.availableRoutes
        });
      });
    }
  }]);

  return TEINodes;
}(React__default["default"].Component);

var TEINode = /*#__PURE__*/function (_React$Component2) {
  _inherits(TEINode, _React$Component2);

  var _super2 = _createSuper(TEINode);

  function TEINode() {
    _classCallCheck(this, TEINode);

    return _super2.apply(this, arguments);
  }

  _createClass(TEINode, [{
    key: "forwardTeiAttributes",
    value: function forwardTeiAttributes() {
      return Array.from(this.props.teiNode.attributes).reduce(function (acc, att) {
        switch (att.name) {
          case 'ref':
            acc['Ref'] = att.value;
            break;

          case 'style':
            acc['style'] = cssjson.exports.toJSON(att.value);
            break;

          default:
            acc[att.name] = att.value;
        }

        return acc;
      }, {});
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      if (!this.props.teiNode) return null;
      var matchName;
      var teiChildren; // Return an element if this is a text node and there is a text() route
      // or if a route matches the current element node's tagname.

      if (this.props.teiNode.nodeType === 3) {
        if (this.props.availableRoutes.includes('text()')) {
          matchName = 'text()';
        } else {
          return this.props.teiNode.nodeValue;
        }
      } else if (this.props.teiNode.nodeType === 1) {
        var el = this.props.teiNode;
        var tagName = el.tagName.toLowerCase();
        teiChildren = /*#__PURE__*/React__default["default"].createElement(TEINodes, _extends({
          teiNodes: el.childNodes
        }, this.props));

        if (this.props.availableRoutes.includes(tagName)) {
          matchName = tagName;
        } else {
          // Return unchanged element.
          return /*#__PURE__*/React__default["default"].createElement(tagName, _objectSpread2({}, this.forwardTeiAttributes()), teiChildren);
        }
      } else {
        return null;
      }

      return /*#__PURE__*/React__default["default"].createElement(TEIRoutes.Consumer, null, function (routes) {
        var selectedRoute = routes[matchName]; // Routes can be given as child elements that are
        // created already and need to be cloned here,
        // or as a component, that is not yet instantiated.

        if ( /*#__PURE__*/React__default["default"].isValidElement(selectedRoute)) {
          return /*#__PURE__*/React__default["default"].cloneElement(selectedRoute, _objectSpread2({}, _this2.props), teiChildren);
        }

        return /*#__PURE__*/React__default["default"].createElement(selectedRoute, _objectSpread2({}, _this2.props), teiChildren);
      });
    }
  }]);

  return TEINode;
}(React__default["default"].Component);

var TEIRoute = /*#__PURE__*/function (_React$Component) {
  _inherits(TEIRoute, _React$Component);

  var _super = _createSuper(TEIRoute);

  function TEIRoute() {
    _classCallCheck(this, TEIRoute);

    return _super.apply(this, arguments);
  }

  _createClass(TEIRoute, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      warning(!(this.props.children && this.props.component), "You should not use child elements and the component attribute\n       at the same time.");
    }
  }, {
    key: "render",
    value: function render() {
      return null;
    }
  }]);

  return TEIRoute;
}(React__default["default"].Component);

var TEIRender = /*#__PURE__*/function (_React$Component2) {
  _inherits(TEIRender, _React$Component2);

  var _super2 = _createSuper(TEIRender);

  function TEIRender(props) {
    var _this;

    _classCallCheck(this, TEIRender);

    _this = _super2.call(this, props);

    _defineProperty(_assertThisInitialized(_this), "availableRoutes", []);

    _defineProperty(_assertThisInitialized(_this), "routes", {});

    React__default["default"].Children.forEach(props.children, function (route) {
      _this.availableRoutes.push(route.props.el);

      if (route.props.children) {
        _this.routes[route.props.el] = route.props.children;
      } else {
        _this.routes[route.props.el] = route.props.component;
      }
    });
    return _this;
  }

  _createClass(TEIRender, [{
    key: "render",
    value: function render() {
      if (!this.props.data) {
        return null;
      }

      return /*#__PURE__*/React__default["default"].createElement(TEIRoutes.Provider, {
        value: this.routes
      }, /*#__PURE__*/React__default["default"].createElement(TEINode, {
        teiNode: this.props.data,
        availableRoutes: this.availableRoutes
      }));
    }
  }]);

  return TEIRender;
}(React__default["default"].Component);

exports.TEINode = TEINode;
exports.TEINodes = TEINodes;
exports.TEIRender = TEIRender;
exports.TEIRoute = TEIRoute;
//# sourceMappingURL=index.js.map
